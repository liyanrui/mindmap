\writestatus{loading}{ConTeXt User Module / mindmap}
\startmodule[mindmap]
\startMPinclusions
% module parameters
numeric MM.level, MM.howfar, MM.stretch, MM.thickness, MM.offset;
numeric MM.head, MM.tail, MM.BEGIN, MM.END, MM.factor;
pair MM.tracker[], MM.handle, MM.currentbase, MM.currentend;
path MM.currentpath;
color MM.branchcolors[], MM.knotcolor;

MM.level := 0; MM.stretch := 1; MM.thickness := 4pt; MM.offset = .125BodyFontSize;
MM.head := 1cm;  MM.tail := 1cm; MM.factor := 1.3; MM.BEGIN := .25; MM.END := .75;
MM.tracker[0] := (0, 0); MM.knotcolor := darkred; MM.handle := (0, 0);
MM.currentbase := (0, 0); MM.currentend := (0, 0); MM.currentpath := (0, 0);
% assume the level number is less than 100.
for i = 0 upto 99: MM.branchcolors[i] := .7white; endfor;
\stopMPinclusions

\startMPinclusions[+]
vardef get_normal_offset(expr p, t, dist)(suffix sign) = 
  save e, f, rot, offset, dx, dy, normal; 
  pair e, f, normal; numeric k, rot, dx; pair offset;
  e := point (t - .05) along p;
  f := point (t + .05) along p;
  dx := xpart f - xpart e;
  dy := ypart f - ypart e;
  if dx = 0:
    if dy >= 0: rot := 90; else: rot := -90; fi;
  else:
    rot := 180 * atan(dy / dx) / pi;
  fi;
  normal := dir(rot + 90);
  if (normal dotprod up) < 0: normal := -normal;  fi;
  offset := dist * normal;
  if dx < 0: sign := -1; fi;
  offset
enddef;

% softness interval [0, 1]
vardef regular_curve(expr a, b, softness) =
  save p, w, h, loc_a, loc_b, loc_ab, u, sign;
  path p; numeric w, h, u, sign; pair loc_a, loc_b, loc_ab;
  w := abs(xpart b - xpart a); h := abs(ypart b - ypart a);
  % doing this can avoid loc_a equals loc_b in the following code.
  if w > 1: w := w - 1; fi;  if h > 1: h := h - 1; fi;
  u := .5softness;
  if w > h:
    if (xpart b - xpart a) >= 0:
      loc_a := a + (u * w, 0); loc_b := b - (u * w, 0);
    else:
      loc_a := a - (u * w, 0); loc_b := b + (u * w, 0);
    fi;
  else:
    if (ypart b - ypart a) >= 0:
      loc_a := a + (0, u * h); loc_b := b - (0, u * h);
    else:
      loc_a := a - (0, u * h); loc_b := b + (0, u * h);
    fi;
  fi;
  % disturbing horizonal or vertical path.
  loc_ab := unitvector(loc_b - loc_a);
  if abs(loc_ab dotprod left) = 1:
    sign := if 0 randomized 1 > 0.5: 1; else: -1; fi;
    loc_a := loc_a + sign * (0, .1w);
    loc_b := loc_b - sign * (0, .1w);
  fi;
  if abs(loc_ab dotprod up) = 1:
    sign := if 0 randomized 1 > 0.5: 1; else: -1; fi;
    loc_a := loc_a + sign * (.1h, 0);
    loc_b := loc_b - sign * (.1h, 0);
  fi;
  p := a .. controls loc_a and loc_b .. b;
  p
enddef;

vardef get_thought_offset(expr p, dist) =
  save offset; pair offset;
  offset := get_normal_offset(p, .5, dist);
  offset
enddef;

vardef polarcoord(expr a, r, angle) =
  save b; pair b; b :=  ((r, 0) rotated angle) shifted a;
  b
enddef;

vardef mind@# text anything =
  save s; string s; s := str @#;
  if s = "": do_mind anything (0); fi;
  if s = "enter": do_mind anything (1); fi;
  if s = "converge": do_mind_converge anything (0); fi;
  if s = "converge.enter": do_mind_converge anything (1); fi;
  if s = "exit": mind_backward ; fi;
  if s = "newroot": do_mind_new anything; fi;
  if s = "base": do_mind_base anything; fi;
  if s = "tailend": do_mind_tailend anything; fi;
  if s = "quote": do_mind_quote anything; fi;
  if s = "handle": do_mind_handle anything; fi;
  if s = "stretch": MM.stretch := anything; fi;
  if s = "colors": mindpath_setcolors anything; fi;
  if s = "knotcolor": MM.knotcolor := anything; fi;
  if s = "thickness": MM.thickness := anything; fi;
  if s = "curve":
    regular_curve anything (.9)
  fi
enddef;

def prepare_branch_parameters(expr name) =
  save L; numeric L.tw, L.howfar, L.howthick; pair L.tracker;
  L.tw := bbwidth textext(name);
  L.howfar := MM.stretch * (MM.head + L.tw + MM.tail);
  L.howthick := MM.thickness;
  for i = 0 upto MM.level:
    L.howthick := L.howthick / MM.factor;
  endfor;
  L.tracker := MM.tracker[MM.level];
enddef;

% this macro can only be used in do_mind, do_mind_converge, do_mind_quote.
def __priv_draw_mind(expr name, p, howthick, tracker) =
  begingroup;
  save sign, pos, q; numeric sign; pair pos; path q;
  MM.handle := point MM.BEGIN along p;
  draw p withpen pencircle scaled howthick withcolor MM.branchcolors[MM.level];
  draw tracker withpen pencircle scaled (howthick + 2pt) withcolor MM.knotcolor;
  q := (p cutbefore MM.handle) cutafter (point MM.END along p);
  sign := 1; pos := get_normal_offset(q, .5, howthick + MM.offset, sign);
  draw lmt_followtext [
    text = name,
    spread = false,
    reverse = (if sign > 0: false else: true fi),
    path = q ] shifted pos;
  endgroup;
enddef;

def do_mind(expr name, angle, action) =
  begingroup;
    save b, p, q, pos, sign;
    pair b, pos; path p, q; numeric sign;
    prepare_branch_parameters(name);
    b := polarcoord(L.tracker, L.howfar, angle);
    p := regular_curve(L.tracker, b, .9);
    __priv_draw_mind(name, p, L.howthick, L.tracker);
    if action > 0: mind_forward(b); fi;
    MM.currentbase := L.tracker;
    MM.currentend := b;
    MM.currentpath := p;
  endgroup;
enddef;

def do_mind_converge(expr name, angle, target, action) =
  begingroup;
    save b, p, q, pos, sign;
    pair b, pos; path p, q; numeric sign;
    prepare_branch_parameters(name);
    b := polarcoord(L.tracker, .5L.howfar, angle);
    p := regular_curve(L.tracker, b, .98);
    p := p .. regular_curve(b, target, .98);
    __priv_draw_mind(name, p, L.howthick, L.tracker);
    if action > 0: mind_forward(target); fi;
    MM.currentbase := L.tracker;
    MM.currentend := target;
    MM.currentpath := p;
  endgroup;
enddef;

def do_mind_quote(expr name, b) =
  begingroup;
    save b, p, q, pos, sign;
    pair b, pos; path p, q; numeric sign;
    prepare_branch_parameters(name);
    p := regular_curve(L.tracker, b, .9);
    draw b withpen pencircle scaled (L.howthick / MM.factor + 2pt) withcolor MM.knotcolor;
    __priv_draw_mind(name, p, L.howthick, L.tracker);
    % for debugging
    MM.currentbase := L.tracker;
    MM.currentend := b;
    MM.currentpath := p;
  endgroup;
enddef;

def do_mind_new(suffix newbase) (expr a) =
  pair newbase; newbase := a;
  MM.tracker[0] := a; MM.level := 0;
enddef;

def do_mind_base(suffix current_base) =
  current_base := MM.currentbase;
enddef;

def do_mind_tailend(suffix current_end) =
  current_end := MM.currentend;
enddef;

def do_mind_handle(suffix current_handle) =
  current_handle := MM.handle;
enddef;

def mind_forward(expr a) =
  MM.level := MM.level + 1;
  MM.tracker[MM.level] := a;
enddef;

def mind_backward =
  MM.level := MM.level - 1;
  if MM.level < 0: message "incorrect mind level."; fi;
enddef;

def mindpath_setcolors(text colors) =
  begingroup;
    save i; numeric i; i = 0;
    for it = colors:
      MM.branchcolors[i] := it;
      i := i + 1;
    endfor;
  endgroup;
enddef;
\stopMPinclusions
\stopmodule
\endinput
