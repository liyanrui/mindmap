\writestatus{loading}{ConTeXt User Module / mindmap}
\startmodule[mindmap]
\startMPinclusions
% module parameters
numeric MM.level, MM.howfar, MM.stretch, MM.thickness, MM.offset;
numeric MM.head, MM.body, MM.tail, MM.start, MM.factor;
pair MM.tracker[], MM.handle, MM.currentbase, MM.currentend;
path MM.currentpath;
color MM.branchcolors[], MM.knotcolor;

MM.level := 0; MM.stretch := 1; MM.thickness := 4pt; MM.offset = .125BodyFontSize;
MM.head := 5mm; MM.body := 1cm; MM.tail := 1cm; MM.start := .2; MM.factor := 1.3;
MM.tracker[0] := (0, 0); MM.knotcolor := darkred; MM.handle := (0, 0);
MM.currentbase := (0, 0); MM.currentend := (0, 0); MM.currentpath := (0, 0);
% assume the level number is less than 100.
for i = 0 upto 99: MM.branchcolors[i] := .7white; endfor;
\stopMPinclusions

\startMPinclusions[+]
vardef get_normal_offset(expr p, t, dist)(suffix sign) = 
  save e, f, rot, offset, dx, dy, normal; 
  pair e, f, normal; numeric k, rot, dx; pair offset;
  e := point (t - .05) along p;
  f := point (t + .05) along p;
  dx := xpart f - xpart e;
  dy := ypart f - ypart e;
  if dx = 0:
    if dy >= 0: rot := 90; else: rot := -90; fi;
  else:
    rot := 180 * atan(dy / dx) / pi;
  fi;
  normal := dir(rot + 90);
  if (normal dotprod up) < 0: normal := -normal;  fi;
  offset := dist * normal;
  if dx < 0: sign := -1; fi;
  offset
enddef;

vardef regular_curve(expr a, b) =
  save p, w, h, loc_a, loc_b, u, loc_ab, sign;
  path p; numeric w, h, sign, u; pair loc_a, loc_b, loc_ab;
  w := abs(xpart b - xpart a);
  h := abs(ypart b - ypart a);
  u := .4;
  if w > h:
    if (xpart b - xpart a) >= 0:
      loc_a := a + (u * w, 0); loc_b := b - (u * w, 0);
    else:
      loc_a := a - (u * w, 0); loc_b := b + (u * w, 0);
    fi;
  else:
    if (ypart b - ypart a) >= 0:
      loc_a := a + (0, u * h); loc_b := b - (0, u * h);
    else:
      loc_a := a - (0, u * h); loc_b := b + (0, u * h);
    fi;
  fi;
  % 不允许出现水平竖直的直线路径
  loc_ab := unitvector(loc_b - loc_a);
  if abs(loc_ab dotprod left) = 1:
    sign := if 0 randomized 1 > 0.5: 1; else: -1; fi;
    loc_a := loc_a + sign * (0, .1w);
    loc_b := loc_b - sign * (0, .1w);
  fi;
  if abs(loc_ab dotprod up) = 1:
    sign := if 0 randomized 1 > 0.5: 1; else: -1; fi;
    loc_a := loc_a + sign * (.1h, 0);
    loc_b := loc_b - sign * (.1h, 0);
  fi;
  p := a .. controls loc_a and loc_b .. b;
  p
enddef;

vardef get_thought_offset(expr p, dist) =
  save offset; pair offset;
  offset := get_normal_offset(p, .5, dist);
  offset
enddef;

vardef polarcoord(expr a, r, angle) =
  save b; pair b; b :=  ((r, 0) rotated angle) shifted a;
  b
enddef;

vardef mind@# text anything =
  save s; string s; s := str @#;
  if s = "": do_mind anything (0); fi;
  if s = "enter": do_mind anything (1); fi;
  if s = "exit": mind_backward ; fi;
  if s = "newroot": do_mind_new anything; fi;
  if s = "base": do_mind_base anything; fi;
  if s = "quote": do_mind_quote anything; fi;
  if s = "handle": do_mind_handle anything; fi;
  if s = "stretch": MM.stretch := anything; fi;
  if s = "colors": mindpath_setcolors anything; fi;
  if s = "knotcolor": MM.knotcolor := anything; fi;
  if s = "thickness": MM.thickness := anything; fi;
  if s = "curve":
    regular_curve anything
  fi
enddef;

def do_mind(expr name, angle, action) =
  begingroup;
    save b, p, q, w, pos, tracker, howfar, howthick, sign;
    pair b, pos, tracker; path p, q; numeric w, howfar, sign;
    w := bbwidth textext(name);
    howfar := MM.head + MM.body + MM.stretch * w + MM.tail;
    howthick := MM.thickness;
    for i = 0 upto MM.level:
      howthick := howthick / MM.factor;
    endfor;
    tracker := MM.tracker[MM.level];
    b := polarcoord(tracker, howfar, angle);
    p := regular_curve(tracker, b);
    draw p withpen pencircle scaled howthick withcolor MM.branchcolors[MM.level];
    draw tracker withpen pencircle scaled (howthick + 2pt) withcolor MM.knotcolor;
    MM.handle := point MM.start along p;
    q := p cutbefore (point (arclength p - w - MM.tail) on p);
    sign := 1; pos := get_normal_offset(q, .5, howthick + MM.offset, sign);
    draw lmt_followtext [
      text = name,
      spread = false,
      reverse = (if sign > 0: false else: true fi),
      path = q ] shifted pos;
    if action > 0: mind_forward(b); fi;
    MM.currentbase := tracker;
    MM.currentend := b;
    MM.currentpath := p;
  endgroup;
enddef;

def do_mind_quote(expr name, b) =
  begingroup;
    save p, q, w, pos, tracker, howthick, sign;
    pair pos, tracker; path p, q; numeric w, howthick, sign;
    tracker := MM.tracker[MM.level];
    howthick := MM.thickness;
    for i = 0 upto MM.level:
      howthick := howthick / MM.factor;
    endfor;
    w := bbwidth textext(name);
    p := regular_curve(tracker, b);
    draw p withpen pencircle scaled howthick withcolor MM.branchcolors[MM.level];
    draw tracker withpen pencircle scaled (howthick + 2pt) withcolor MM.knotcolor;
    draw b withpen pencircle scaled (howthick / MM.factor + 2pt) withcolor MM.knotcolor;
    MM.handle := point MM.start along p;
    sign := 1; pos := get_normal_offset(p, .5, howthick + MM.offset, sign);
    draw lmt_followtext [
      text = name,
      spread = false,
      reverse = (if sign > 0: false else: true fi),
      path = p ] shifted pos;
    % for debugging
    MM.currentbase := tracker;
    MM.currentend := b;
    MM.currentpath := p;
  endgroup;
enddef;

def do_mind_new(suffix newbase) (expr a) =
  pair newbase; newbase := a;
  MM.tracker[0] := a; MM.level := 0;
enddef;

def do_mind_base(suffix current_base) =
  current_base := MM.currentbase;
enddef;

def do_mind_handle(suffix current_handle) =
  current_handle := MM.handle;
enddef;

def mind_forward(expr a) =
  MM.level := MM.level + 1;
  MM.tracker[MM.level] := a;
enddef;

def mind_backward =
  MM.level := MM.level - 1;
  if MM.level < 0: message "incorrect mind level."; fi;
enddef;

def mindpath_setcolors(text colors) =
  begingroup;
    save i; numeric i; i = 0;
    for it = colors:
      MM.branchcolors[i] := it;
      i := i + 1;
    endfor;
  endgroup;
enddef;
\stopMPinclusions
\stopmodule
\endinput
